# libevent 基本原理

## libevent 介绍
* libevent是用于开发可扩展的网络服务的基于事件通知的网络库。
  libevnet API提供了一个机制，在文件描述符上的IO事件，信号事件或者超时事件发生时，
  执行事件的回调函数。

* libevent用于替代事件驱动的网络服务中的事件循环。应用只需要调用event_dispatch()
  方法就可以在不需要改动事件循环的情形下自动的添加、删除事件。

* libevent支持如下IO多路复用机制：/dev/poll, kqueue, select, poll, epoll。同时也支持实时信号。  
  内部的事件机制是对暴露的API的完整实现，libevent的更新升级不需要重新更改整个应用。  
  因此，libevent简化了应用开发，提供了可扩展的事件通知机制。 libevent也可以用于多线程应用。 
  
## libevent 主要模块
* event - 事件
> libevent 支持io 定时 信号事件
* eventHandler - 事件处理程序
* reactor
>使用eventDemultiplexer注册、注销事件  
运行事件循环  
当有事件进入就绪状态时，调用注册的回调函数进行处理
* eventDemultiplexer
>由操作系统提供的io多路分发机制，如select,  poll, epoll
  
## libevent 使用方法

* 使用libevent的程序，需要引入< event.h > 头文件，编译时加上参数-levent。
  在使用前，需要调用 **event_init()** 或 **event_base_new()** 来初始化libevent库。
* 对于你想监控的每个文件描述符，你都需要声明一个event结构体，再调用 **event_set()** 方法来初始化结构体的属性成员。
* 激活事件通知机制，需要调用 **event_add()** 方法把event结构体加入到监控事件列表中。  
event结构体在堆内存中进行分配，只要事件在激活状态，就会一直保存在内存中。
* 最后，调用event_dispatch()方法来进入事件循环。

## libevent 代码结构

1. event.h - libevent网络库的头文件。包含了libevent的概要说明。
    event2/event-structrue.h - libevent主要结构体event的声明
    event2/event.h - libevent提供的接口声明
    event-internal.h 事件处理框架event_base结构体的声明
2. event.c - libevent整体框架的代码实现
3. 系统IO多路复用机制的封装：epoll.c select.c devpoll.c kqueue.c
4. 信号管理： signal.c
5. 缓冲区管理： evbuffer.c buffer.c
6. 辅助函数： evutil.h evutil.c
7. 日志： log.h log.c
8. 基本数据结构： min-heap.h queue.h  libevent_time.h
9. libevent提供的基础应用： dns.h http.h evrpc.h

### event结构体

```
struct event {
	TAILQ_ENTRY(event) ev_active_next;  //就绪事件链表节点
	TAILQ_ENTRY(event) ev_next;  //已注册的事件链表节点
	/* for managing timeouts */
	union {
		TAILQ_ENTRY(event) ev_next_with_common_timeout;
		int min_heap_idx;  
	} ev_timeout_pos;  //管理定时事件 (小根堆索引和链表节点)
	evutil_socket_t ev_fd;  //事件源，文件描述符

	struct event_base *ev_base;   //事件处理框架

	union {
		/* used for io events */
		struct {
			TAILQ_ENTRY(event) ev_io_next;
			struct timeval ev_timeout;
		} ev_io;   //管理io事件 (io事件链表节点)

		/* used by signal events */
		struct {
			TAILQ_ENTRY(event) ev_signal_next;
			short ev_ncalls;
			/* Allows deletes in callback */
			short *ev_pncalls;
		} ev_signal;  //管理信号事件 (signal事件链表节点)
	} _ev;

	//event事件类型，包括：
	//1. I/O事件： EV_WRITE和EV_READ 
	//2. 定时事件：EV_TIMEOUT
	//3. 信号：    EV_SIGNAL 
	short ev_events;   
	//ev_res和ev_flags是事件激活后回调的结果
	short ev_res;		/* result passed to event callback */ //记录了当前激活事件的类型,是读事件还是写事件等
	//用于记录事件的状态，包括：
	//#define EVLIST_TIMEOUT    0x01 
	//#define EVLIST_INSERTED   0x02  事件已经插入到事件列表中。
	//#define EVLIST_SIGNAL        0x04
	//#define EVLIST_ACTIVE        0x08   事件处于激活状态
	//#define EVLIST_INTERNAL  0x10  
	//#define EVLIST_INIT      0x80  事件已经初始化
	short ev_flags;   
	ev_uint8_t ev_pri;	/* smaller numbers are higher priority */  //记录事件的优先级，数字越小，优先级越高
	//记录事件的终止方式，根据ev_closure的值，当事件发生时，按相应策略执行回调函数
	//#define EV_CLOSURE_NONE 0  （对应除了下面两个之外的其他事件类型）
    //#define EV_CLOSURE_SIGNAL 1  （对应的事件类型：EV_SIGNAL）
	//#define EV_CLOSURE_PERSIST 2 (对应的事件类型：EV_PERSIST)
	ev_uint8_t ev_closure;
	struct timeval ev_timeout;  //timeout事件的超时值

	/* allows us to adopt for different types of events */
	void (*ev_callback)(evutil_socket_t, short, void *arg);  //回调函数
	void *ev_arg;     //回调函数的参数
};
```

### event_base 结构体
``` C
struct event_base {
	const struct eventop *evsel;  //指向全局变量static const struct eventop * eventops[]中的一个，对应着底层的io多路复用实现
	void *evbase;  //eventop的实例对象

	struct event_changelist changelist;  //用于告知后端下一次执行事件分发时需要注意的事件列表

	const struct eventop *evsigsel;  //专门用于处理信号事件的eventop
	struct evsig_info sig;  //存储信号处理的信息

	int virtual_event_count;  //虚拟事件的个数
	int event_count;  //总事件的个数
	int event_count_active;  //就绪事件的个数

	int event_gotterm;  //事件循环退出标记，在处理完事件后退出
	int event_break;  //事件循环退出标记，立即退出

	int running_loop;  //立即启动一个新的事件循环

	struct event_list *activequeues;  //就绪事件队列数组，数组的每个元素保存着一个特定优先级的就绪队列事件链表
	int nactivequeues;    //就绪事件队列长度

	struct common_timeout_list **common_timeout_queues;  //定时到期事件数组
	int n_common_timeouts;
	int n_common_timeouts_allocated;

	struct deferred_cb_queue defer_queue;  //要延迟处理的就绪事件队列

	struct event_io_map io;   //io事件队列
	struct event_signal_map sigmap;  //信号事件队列
	struct event_list eventqueue;  //链表，保存所有注册的事件

	struct timeval event_tv;    //保存后端dispatch()上次返回的时间

	struct min_heap timeheap;  //保存定时事件的小根堆

	struct timeval tv_cache;  //时间缓存，防止频繁的进行获取当前时间的系统调用

#ifndef _EVENT_DISABLE_THREAD_SUPPORT //多线程支持
	unsigned long th_owner_id;
	void *th_base_lock;
	struct event *current_event;
	void *current_event_cond;
	int current_event_waiters;
#endif

#ifdef WIN32
	struct event_iocp_port *iocp;
#endif

	enum event_base_config_flag flags;

	int is_notify_pending;
	evutil_socket_t th_notify_fd[2];
	struct event th_notify;
	int (*th_notify_fn)(struct event_base *base);
};
```

### libevent API
* struct event_base *event_init(void)  
>初始化libevent。  
为event_base结构体申请空间，初始化event_base结构体的成员。

* event_set(struct event *ev, evutil_socket_t fd, short events,void (*callback)(evutil_socket_t, short, void *), void *arg)
>设置事件  
**ev**: 事件event；**fd**: 事件源，文件描述符；**events**: 在事件源上所关注的事件类型，如EV_READ, EV_WRITE, EV_SIGNAL；**callbak**: 回调函数, 当fd上的event发生时，调用该函数执行处理；**arg**: 回调函数的参数  
初始化event结构体的成员。

* int event_add(struct event *ev, const struct timeval *tv)
>注册事件
根据事件的类型（IO、信号、定时）将event结构体加入到相应的事件队列中。  
先注册IO或信号事件，成功后再注册定时事件。

* int event_base_loop(struct event_base *base, int flags)
>事件处理主循环 ：  
更新系统时间  
根据timer_heap中事件的最小超时事件，计算后端io多路服用的最大等待时间   
调用后端io多路服用服务，等待就绪事件的发生，将就绪的io或信号事件插入到激活事件队列中  
将就绪的time_event从小根堆上删除，并加入到激活事件队列中  
调用event_process_active() 处理激活队列中的就绪事件，调用事件回调函数进行处理

